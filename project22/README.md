# Project22: research report on MPT
MPT (Merkle Patricia Tries) 是以太坊存储数据的核心数据结构，它是由 Merkle Tree 和 Patricia Tree 结合所组成的一种树形结构，理解 MPT 有助于帮助我们更好的理解以太坊的数据存储。<br>
首先我们介绍基本的Trie Tree 结构和 Merkle Tree、Patricia Tree这两种特殊结构，在此基础上我们研究MPT的结构特点及其优点与应用。<br>

## Trie Tree
TrieTree，又称字典树或前缀树，是一种有序树，典型应用是用于统计，排序和保存大量的字符串。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。
其核心思想就是用空间换时间，利用公共前缀缩小要比较的范围来达到快速查找的目的。字典树主要包含两种操作，插入和查找。<br>
相比于哈希表，使用前缀树来进行查询拥有共同前缀key的数据时十分高效，例如在字典中查找前缀为pre的单词，对于哈希表来说，需要遍历整个表，时间效率为O(n)，
然而对于前缀树来说，只需要在树中找到前缀为pre的节点，且遍历以这个节点为根节点的子树即可。但是对于最差的情况（前缀为空串)，时间效率为O(n),仍然需要遍历整棵树，此时效率与哈希表相同。<br>
下图所示Trie Tree表示了字符串集合{"ab","acd","ace","acf","g","hij"}。<br>

Trie Tree的特点如下：<br>
1、根节点不包含字符，除根节点外的每一个子节点都包含一个字符。<br>
2、从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。<br>
3、每个节点的所有子节点包含的字符互不相同<br>

需要注意的是Trie Tree存在一定的缺陷，当存在少量的长字符串，且某个较长前缀下只有本身一个元素时，树的高度会很大，且一条长路径上只有一个叶节点。
这样极大地浪费存储空间，且应用起来效率也不高。<br>

## Patricia Tree
压缩前缀树，是一种更节省空间的 Trie Tree。对于树的每个节点，如果该节点是唯一的子节点，就和父节点合并。<br>

## Merkle Tree
Merkle Tree是一种哈希树，用于编码大块的信息。 其中每个叶子节点都标有数据块的加密哈希值，而每个非叶子节点都标有其子节点的加密哈希值的标签。 
大多数哈希树的实现是二进制的（每个节点有两个子节点），但它们也可以有更多的子节点。 
Merkle Tree的特别之处在于，这是一种自下而上建立的树，允许你验证某些值是否存在于树中，而不需要在树的每个元素上循环，这一特点非常有用。<br>

## MPT
MPT，即Merkle Patricia Tree。是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是以太坊中用来组织管理账户数据、生成交易集合哈希的重要数据结构。<br>

MPT树有以下几个作用：<br>

1、存储任意长度的key-value键值对数据，符合以太坊的state模型；<br>
2、提供了一种快速计算所维护数据集哈希标识的机制；<br>
3、提供了快速状态回滚的机制；<br>
4、提供了默克尔证明，进行轻节点的扩展，实现简单支付验证；<br>

MPT树中的节点包括空节点、叶子节点、扩展结点和分支节点。<br>

1、空节点（NULL）：表示为空，在代码中是一个空串。<br>
2、叶子节点（leaf）：表示为 [key,value]的一个键值对，其中key是key的一种特殊十六进制编码(MP编码)， value是value的RLP编码。<br>
3、拓展节点（extension）：也是[key,value],但是这里的value是其他节点的hash，通过这个hash链接到其他节点。<br>
4、分支节点（branch）：MPT中的key被序列化成一种特殊的16进制编码，加上最后的value，
所以分支节点是一个长度为17的list，前16个元素对应着key中的16个可能的十六进制字符。如果有一个[key,value]对在这个分支节点终止，则最后一个元素代表一个值
（例如，有三个key，分别是（abc，abd，ab），则该节点的第17个字段存储了ab节点的值）即分支节点既可以是搜索路径的终止也可以是路径的中间节点。
对应于Trie中的关键路径节点。<br>

MPT树的结构特点如下:<br>

1、叶子节点和分支节点可以保存value, 扩展节点保存key；<br>
2、没有公共的key就成为2个叶子节点；key1=[1,2,3] key2=[2,2,3]<br>
3、有公共的key需要提取为一个扩展节点；key1=[1,2,3] key2=[1,3,3] => ex-node=[1],下一级分支node的key<br>
4、如果公共的key也是一个完整的key，数据保存到下一级的分支节点中；key1=[1,2] key2=[1,2,3] =>ex-node=[1,2],下一级分支node的key; 
下一级分支=[3],上一级key对应的value<br>

使用MPT的主要原因在于：<br>

设计在扩展节点的Val字段有可能存储一串哈希值作为孩子节点的索引，这一点符合Trie的特性。
在以太坊中，该哈希代表着另外一个节点在数据库中索引，即根据这个哈希值作为数据库中的索引，可以从数据库中读取出另外一个节点的内容。<br>
这种设计的目的是：<br>
1、当整棵树被持久化到数据库中时，保持节点间的关联关系；
2、从数据库中读取节点时，尽量避免不必要的IO开销；

MPT结合了Merkle Tree和Patricia Trie的优势，概括如下：<br>

1、可以实现快速重哈希。<br>
当树节点内容发生变化时，能够在前一次哈希计算的基础上，仅仅将被修改的树节点进行哈希重计算，便能得到一个新的根哈希用来代表整棵树的状态。<br>

2、可以进行轻节点扩展，验证一条交易只需要验证包含该交易的路径即可，并不需要把所有交易的Hash全部重新算一遍。<br>

3、能够实现快速状态回滚。<br>
区块链公链的环境下，可能会造成分叉而导致区块链状态需要进行回滚，由于出块时间短，这种分叉的几率很大，区块链状态回滚的现象很频繁。<br>
所谓的状态回滚指的是：<br>
（1）区块链内容发生了重组织，链头发生切换<br>
（2）区块链的世界状态（账户信息）需要进行回滚，即对之前的操作进行撤销。<br>
每个节点在数据库中的存储都是值驱动的。当一个节点的内容发生了变化，其哈希相应改变，
而MPT将哈希作为数据库中的索引，也就实现了对于每一个值，在数据库中都有一条确定的记录。而MPT是根据节点哈希来关联父子节点的，
因此每当一个节点的内容发生变化，最终对于父节点来说，改变的只是一个哈希索引值；父节点的内容也由此改变，产生了一个新的父节点，递归地将这种影响传递到根节点。
最终，一次改变对应创建了一条从被改节点到根节点的新路径，而旧节点依然可以根据旧根节点通过旧路径访问得到。
所以，在以太坊中，发生分叉而进行世界状态回滚时，只需要用旧的MPT根节点作为入口，就能完成一次“状态回滚”。<br>

MPT在以太坊中被广泛使用。交易清单，收据清单，世界状况和合同数据均由MPT构建。<br>
以世界状态为例，表示为键值集结构。关键是帐户地址，值是一个4元组值：[nonce，balance，storageRoot，codeHash]。
在以太坊中，世界状态在整个网络中存储整个网络中所有帐户的状态消息一段时间。当交易发生或智能合约运行时，帐户的状态可能会发生变化。
MPT 用于帮助生成新的哈希值，在状态更改期间计算更少。此外，只要存在可靠的ROOT，就可以快速验证来自不受信任来源的帐户状态。
此外，MPT本质上是Patricia Trie，因此可以按地址快速搜索帐户状态。
多亏了MPT，以太坊节点能够只在区块头中存储交易列表ROOT、接收列表ROOT、世界状态ROOT和合约数据ROOT，并分别存储或传输详细的数据信息和区块头，使轻量级节点成为可能。<br>
综上所述，MPT在存储键值数据方面具有独特的优势。

