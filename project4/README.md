# Project4: do your best to optimize SM3 implementation (software)
## 一、实验原理
### 宏定义
宏定义是一种预处理命令，它允许用一个标识符来表示一个字符串。<br>
简单的宏定义有如下格式：[#define指令]，其中指令包括标识符和替换列表。<br>
当预处理器遇到一个宏定义时，会做一个“标识符”代表“替换列表”的记录。在文件后面的内容中，不管标识符在任何位置出现，预处理器都会用替换列表代替它。宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。

### SIMD指令集
SIMD即单指令流多数据流（英语：Single Instruction Multiple Data），是一种采用一个控制器来控制多个处理器，
同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术，是CPU基本指令集的扩展。

### 循环展开
loop unrolling(循环展开)，即增加每一步loop时的步长，在增加步长之后，在循环体内补充上所需要的操作，使其在前后功能完善不变的情况下减少循环次数，进而减少循环开销。

## 二、实验思路
首先根据SM3说明文档，编写SM3的各个基本组件。包括布尔函数、置换函数、消息扩展函数、压缩函数。<br>
本次实验通过宏定义、SIMD指令集以及算法优化等方法来实现对SM3的优化。具体优化思路如下。<br>

### 布尔函数
![布尔函数](https://github.com/hsgroup30num1/homework-group-30/assets/129477640/e772ff0b-6b1f-4977-83fe-54be8736e19c)

#### 优化：利用C语言的宏定义来代替函数，从而避免函数调用引起的开销。
优化代码如下：<br>
```c
#define FF0(x,y,z)  (x ^ y ^ z)
#define FF1(x,y,z)  ((x & y) | (x & z) | (y & z))

#define GG0(x,y,z)  (x ^ y ^ z)
#define GG1(x,y,z)  ((x & y) | ((~x) & z))
```
### 置换函数
![置换函数](https://github.com/hsgroup30num1/homework-group-30/assets/129477640/ac586d36-6ba1-4623-86d4-d7113773bec4)

### 消息扩展函数
![消息扩展函数](https://github.com/hsgroup30num1/homework-group-30/assets/129477640/e655a62a-f375-45da-bed5-60fe44d0fd0c)

#### 优化：利用SIMD指令集同时处理多组数据。
SM3说明文档中的消息扩展是对32位字进行独立的操作，由于其相互之间没有依赖关系，因此我们可以考虑用SIMD来同时处理多组数据。<br>
消息扩展中使用了w[j-3]，w[j-6] ... 来计算w[j]。跨度最小的是当前位置向前三个，这样的时序关系限制了最大的并行度。
也就是说，由于需要使用前面的状态，最多只能同时处理三组数据。一旦超过三，则第四个32位字w[j+3]的计算就需要用到尚未得到的w[j]，而这是不可行的。<br>
因此使用128位的SIMD指令集是最合适的，每次同时处理三个32位字，只会空出一个字的位置。使用更大的宽度是没有意义的。

### 压缩函数
![压缩函数](https://github.com/hsgroup30num1/homework-group-30/assets/129477640/d0bd4415-2d52-4c5f-b6a2-75607a7a944a)

#### 优化：
#### 1、利用C语言的宏定义来代替函数，从而避免函数调用引起的开销。
#### 2、循环展开

分析压缩函数可知，轮函数共循环执行64次。以下以第一次轮函数为例来进行循环展开。<br>
当第一次执行完毕后，有这样的关系：<br>

A=TT1<br>
B=A<br>
C=B<<9<br>
D=C<br>
E=P_0(TT2)<br>
F=E<br>
G=f<<19<br>

当我们下一次迭代时，需要的参数仍然是按A~H顺序排列。<br>

在下一次迭代中有这样的关系：<br>

Func(A',B',C',D',E',F',G',H')等价于Func(TT1,A,B<<9,C,P_0(TT2),E,F<<19,G)<br>

可以看到，各个参数所关联的字寄存器仍然按照一定的规律排列，这里可以看作是H,A,B,C,D,E,F,G。<br>
因此只需要让对应的寄存器满足对应位置的值，即<br>

H=TT1<br>
B=B<<9<br>
F=F<<19<br>
D=P_0(TT2)<br>

这样，下一次调用Func(TT1,A,B<<9,C,P_0(TT2),E,F<<19,G)就等价于Func(H,A,B,C,D,E,F,G),看起来是将参数循环右移。<br>

这样迭代8次后，就会回到最初的情况。因此，可以将8次迭代作为一组，总共8组实现展开。<br>

## 三、实验结果
对“abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd”进行SM3加密。<br>
由于单次运行时间较短，为了方便测算时间，我们重复进行1000000次SM3运算，运行结果如下。<br>
![SM3_optimize](https://github.com/hsgroup30num1/homework-group-30/assets/129477640/18518f34-3307-46e4-b132-cb0cdfcfbccf)

首先对比密文确认算法的正确性。<br>
1000000次运算共耗时3.41s<br>
平均每次SM3运算耗时3.4μs<br>
由于每次运算512bit分组，因此吞吐率可达18.82MB/s<br>
