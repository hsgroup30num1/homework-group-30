# Project4: do your best to optimize SM3 implementation (software)
## 一、实验原理

## 二、实验思路
首先根据SM3说明文档，编写SM3的各个基本组件。包括布尔函数、置换函数、消息扩展函数、压缩函数。<br>
本次实验通过宏定义、SIMD指令集以及算法优化等方法来实现对SM3的优化。具体优化思路如下。<br>

### 布尔函数
![布尔函数](https://github.com/hsgroup30num1/homework-group-30/assets/129477640/e772ff0b-6b1f-4977-83fe-54be8736e19c)

#### 优化：利用C语言的宏定义来代替函数，从而避免函数调用引起的开销。
优化代码如下：<br>
```c
#define FF0(x,y,z)  (x ^ y ^ z)
#define FF1(x,y,z)  ((x & y) | (x & z) | (y & z))

#define GG0(x,y,z)  (x ^ y ^ z)
#define GG1(x,y,z)  ((x & y) | ((~x) & z))
```
### 置换函数
![置换函数](https://github.com/hsgroup30num1/homework-group-30/assets/129477640/ac586d36-6ba1-4623-86d4-d7113773bec4)

### 消息扩展函数
![消息扩展函数](https://github.com/hsgroup30num1/homework-group-30/assets/129477640/e655a62a-f375-45da-bed5-60fe44d0fd0c)

#### 优化：利用SIMD指令集同时处理多组数据。
SM3说明文档中的消息扩展是对32位字进行独立的操作，由于其相互之间没有依赖关系，因此我们可以考虑用SIMD来同时处理多组数据。<br>
消息扩展中使用了w[j-3]，w[j-6] ... 来计算w[j]。跨度最小的是当前位置向前三个，这样的时序关系限制了最大的并行度。
也就是说，由于需要使用前面的状态，最多只能同时处理三组数据。一旦超过三，则第四个32位字w[j+3]的计算就需要用到尚未得到的w[j]，而这是不可行的。<br>
因此使用128位的SIMD指令集是最合适的，每次同时处理三个32位字，只会空出一个字的位置。使用更大的宽度是没有意义的。

### 压缩函数
![压缩函数](https://github.com/hsgroup30num1/homework-group-30/assets/129477640/d0bd4415-2d52-4c5f-b6a2-75607a7a944a)

#### 优化：
#### 1、利用C语言的宏定义来代替函数，从而避免函数调用引起的开销。
#### 2、循环展开

分析压缩函数可知，轮函数共循环执行64次。以下以第一次轮函数为例来进行循环展开。<br>
当第一次执行完毕后，有这样的关系：<br>

A=TT1<br>
B=A<br>
C=B<<9<br>
D=C<br>
E=P_0(TT2)<br>
F=E<br>
G=f<<19<br>

当我们下一次迭代时，需要的参数仍然是按A~H顺序排列。<br>

在下一次迭代中有这样的关系：<br>

Func(A',B',C',D',E',F',G',H')等价于Func(TT1,A,B<<9,C,P_0(TT2),E,F<<19,G)<br>

可以看到，各个参数所关联的字寄存器仍然按照一定的规律排列，这里可以看作是H,A,B,C,D,E,F,G。<br>
因此只需要让对应的寄存器满足对应位置的值，即<br>

H=TT1<br>
B=B<<9<br>
F=F<<19<br>
D=P_0(TT2)<br>

这样，下一次调用Func(TT1,A,B<<9,C,P_0(TT2),E,F<<19,G)就等价于Func(H,A,B,C,D,E,F,G),看起来是将参数循环右移。<br>

这样迭代8次后，就会回到最初的情况。因此，可以将8次迭代作为一组，总共8组实现展开。<br>

## 三、实验结果
